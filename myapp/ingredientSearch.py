import http.client
import urllib.parse
import time
import hmac
import hashlib
import base64
import uuid
import json 
import re
from dotenv import load_dotenv
import os
from rateLimitMonitor import rate_limited_api_call

'''
Description: Generates a randomly generated string for a request that can be combined with the timestamp to produce 
a unique value(FatSecret 2024).
Parameters: None
Return: a randomly generated string
''' 
def generate_nonce():
    return str(uuid.uuid4().hex)

'''
Description: Generates a timestamp of date and time, expressed in the number of seconds since January 1, 1970 00:00:00 GMT. 
The timestamp value must be a positive integer and must be equal or greater than the timestamp used in previous requests
(FatSecret 2024).
Parameters: None
Return: a timestamp of date and time
''' 
def generate_timestamp():
    return str(int(time.time()))

'''
Description: Generates a (%xx) mechanism and concatenated by an '&' character used to encode parameters
Parameters: string - string to encode
Return: a (%xx) mechanism and concatenated by an '&' character
''' 
def percent_encode(string):
    return urllib.parse.quote(string, safe='')

'''
Description: Generates a signature base string by concatenating the HTTP method (GET or POST), the Request URL, and the
query parameters (FatSecret 2024).
Parameters: http method - supports both HTTP methods GET and POST
            base url - the fat secret api url
            params - the query parameters
Return: the signature base string
''' 
def generate_signature_base_string(http_method, base_url, params):
    sorted_params = '&'.join(['{}={}'.format(percent_encode(k), percent_encode(v)) for k, v in sorted(params.items())])
    return '&'.join([http_method.upper(), percent_encode(base_url), percent_encode(sorted_params)])

'''
Description: Generates a signature, a consistent reproducible concatenation of the request elements into a single string. 
The string is used as an input in hashing or signing algorithms (FatSecret 2024).
Parameters: signature_base_string - created by concatenating the HTTP method (GET or POST), the Request URL, 
            and the query parameters(FatSecret 2024).
            consumer_secret - unique code generated by the Fat Secret API
            token_secret - not used
Return: a timestamp of date and time
''' 
def generate_signature(signature_base_string, consumer_secret, token_secret=''):
    signing_key = '&'.join([percent_encode(consumer_secret), percent_encode(token_secret)])
    hashed = hmac.new(signing_key.encode('utf-8'), signature_base_string.encode('utf-8'), hashlib.sha1)
    return base64.b64encode(hashed.digest()).decode('utf-8')

'''
Description: calls the Fat Secret API on an ingredient to retrieve calorie, fat, carb, and protein information for an 
ingredient. The API called using a rate limit monitor to limit the number of times the API gets called in the last 24 hours.
Parameters: ingredient - the ingredient that data is requested from the API of
Return: a dictionary of the ingredient nutrition facts
''' 
def searchIngredient(ingredient):
    load_dotenv()
    consumer_key = os.getenv('consumer_key')
    consumer_secret = os.getenv('consumer_secret')

    oauth_params = {
        'oauth_consumer_key': consumer_key,
        'oauth_signature_method': 'HMAC-SHA1',
        'oauth_timestamp': generate_timestamp(),
        'oauth_nonce': generate_nonce(),
        'oauth_version': '1.0',
    }

    api_params = {
        'method': 'foods.search',
        'search_expression': ingredient,
        'format': 'json',
        'max_results': '10',
        'page_number': '0'
    }

    all_params = {**oauth_params, **api_params}

    base_url = 'https://platform.fatsecret.com/rest/server.api'
    signature_base_string = generate_signature_base_string('GET', base_url, all_params)

    oauth_signature = generate_signature(signature_base_string, consumer_secret)
    all_params['oauth_signature'] = oauth_signature

    def make_get_request(base_url, all_params, retries=3, delay=2):
        for attempt in range(retries):
            try:
                conn = http.client.HTTPSConnection('platform.fatsecret.com')
                query_string = urllib.parse.urlencode(all_params)
                conn.request('GET', f'/rest/server.api?{query_string}')
                response = conn.getresponse()
                data = response.read().decode('utf-8')
                conn.close()
                return data
            except Exception as e:
                print(f"Exception occurred: {e}. Retrying...")
            # Wait before retrying the request
            time.sleep(delay)
        print("Max retries exceeded. Returning None.")
        return None  # Return None if max retries are exceeded

    print("performing rate limit")
    response = rate_limited_api_call(make_get_request, base_url, all_params)
    # response = make_get_request(base_url, all_params)
    
    # Parse the JSON response into a dictionary
    response_dict = json.loads(response)
    
    # Access the "food_description" for each food item
    foods = response_dict.get('foods', {}).get('food', [])

    # using regular experession to change format of food description to dictionary
    pattern = r"Per (?P<amount>[\d\s\w]+) - Calories: (?P<calories>\d+kcal) \| Fat: (?P<fat>\d+\.\d+g) \| Carbs: (?P<carbs>\d+\.\d+g) \| Protein: (?P<protein>\d+\.\d+g)"

    food_description = ""
    if foods == [] or foods == {}:
        # print(f"No results found for ingredient: {ingredient}")
        return None
    if type(foods) == dict:
        food_description = foods['food_description']
    else:
        food_description = foods[0].get('food_description', None)
    
    # if foods exists
    if food_description == None:
        # print(f"Food description is None for ingredient: {ingredient}")
        return None
    match = re.search(pattern, food_description)

    if match == None:
        # print(f"Regex pattern did not match for ingredient: {ingredient}. Description: {food_description}")
        return None

    nutrition = match.groupdict()
    

    results = {}
    results[ingredient] = nutrition
    return results
